# plan-to-watch

В этом задании будем делать реактивный список сериалов

Код в задачке написан с использованием идей web-components, их знание не обязательно, ссылки на почитать:

- https://developer.mozilla.org/en-US/docs/Web/Web_Components
- https://www.webcomponents.org/introduction

## Задания:

0. Для дебага пригодится расширение [mobx-devtools](https://github.com/mobxjs/mobx-devtools)
1. Сначала оживим работу с элементами списка и просмотренными сериями:
   - В файле `models/entry.ts` добавь в методы подходящую логику обработки изменений количества серий
   - В файле `components/Entry.ts` в обработчиках событий, связанных с изменением количества серий, добавь вызов правильных методов модели
   - В файле `models/entry.ts` добавь необходимые аннотации в вызов `makeObservable()`, чтобы нужные поля стали observable, а нужные методы стали action-ами
   - В файле `components/Entry.ts` сделай так, чтобы логика отрисовки количества серий вызывалась автоматически. Убедись, что ты компонент корректно отписывается, когда происходит disconnect
2. После выполнения предыдущего шага, форма ввода и кнопки +/- должны менять количество серий. Заметь, что суммарное количество серий при этом не обновляется, давай это исправим:
   - В файле `models/list.ts` преврати поле `total` в геттер и добавь необходимую аннотацию, чтобы оно превратилось в computed
   - В файле `components/List.ts` сделай так, чтобы логика отрисовки суммарного количества серий вызывалась автоматически
   - Теперь, при изменении количества серий в любом из элементов списка, должен корректно обновляться суммарный счетчик серий
3. Пришло время настроить работу со статусами:
   - В файле `models/entry.ts` напиши логику обновления статуса. Не забудь добавить аннотацию, чтобы поле статуса стало observable
   - Учти, что при переносе в статус `Completed` нужно также обновлять просмотренные серии, если общее количество известно. Обратное тоже верно — при достижении максимального количества серий нужно изменять статус на `Completed`
   - В файле `components/Entry.ts` сделай так, чтобы обработчик звал нужный метод модели, а отрисовка статуса происходила автоматически. Не забудь отписаться в нужный момент
   - Теперь логика изменения статуса должна работать. Убедись, что работают оба сценария достижения конца серий (меняется статус или меняется количество серий). Заметь, что при установке статуса `Completed` меняется не только количество серий у элемента списка, но и общий счетчик серий
4. Теперь нужно починить логику фильтрации списка:
   - В файле `models/list.ts` напиши логику изменения `mode`. Не забудь нужные аннотации в конструкторе, чтобы поле стало observable
   - В файле `components/Navigation.ts` сделай так, чтобы при клике на ссылку происходило изменения `mode`, а отрисовка активной вкладки происходила автоматически
   - Сделай так, чтобы список элементов фильтровался согласно выбранной вкладке. Для этого в файле `models/list.ts` преврати поле `showing` в computed геттер, а в файле `components/List.ts` добавь автоматическую отрисовку элементов списка
   - Если все сделано правильно, то теперь при переключении вкладки в списке останутся только подходящие элементы, а при изменении статуса элемента, он исчезнет из списка, если не подходит под текущий фильтр
   - Заметь, что при переключении вкладки изменяется и общий счетчик серий. Попробуй представить граф зависимостей для этого значения
5. \* Сделай так, чтобы заработало удаление элементов списка. Для этого в файле `models/list.ts` допиши логику удаления, а в файле `components/Entry.ts` позови ее в обработчике события удаления. Заметь, что при удалении элемента он должен пропасть из списка, а счетчик серий уменьшиться на соответствующее количество серий. Снова подумай о графе зависимостей счетчика серий :)
6. \* Сделай так, чтобы заработало добавление элементов списка. Для этого:
   - Сделай поле `isAdding` observable
   - Напиши логику его обновления
   - Вызови эту логику в обработчике показа формы добавления в файле `components/Input.ts`
   - Сделай автоматическую отрисовку формы или кнопки
   - Напиши логику добавления нового элемента
   - Позови эту логику на отправку формы
